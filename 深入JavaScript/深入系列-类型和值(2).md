# 深入JavaScript-类型和值(2)-强制(隐式)类型转换

> 闇に惑いし哀れな影よ

## 前言

人们对JavaScript中最大的偏见,最多的指责,莫过于这强制类型转换了。
这到底是设计的缺陷还是有用的特性，这个争论从JavaScript诞生之日就开始。
不少人选择退缩,使用更多的等号来填满心中的不安。
我们来看看这个魔鬼的特性吧

我们同样要思考，代码是给人看，而不是仅仅给机器进行执行的，在编码过程中竟可能将类型转换表达清楚，以免给别人留坑。更深的了解类型转换不是为了在代码中"花式炫技"

## ToBoolean 布尔值

### falsy value 假值

#### JavaScript中的值可以分为下面两类

- 1.可以被强制类型转换为false的值
- 2.其他

其中这些假值是有限的

- undefined
- null
- false
- +- 0 NaN
- ""

除此以外所有其他值都可以理解为真值，请尤其小心谨慎下面这些容易发生误会的值

- "false"
- "0"
- "''"
- []
- {}
- [0]
- function(){}

// 当然以上值中最坑的应该是[] {},他虽然是真值,但是在ToPromitive解析中却返回的是假值，下面会讲到这个问题

接下来要说一个非常重要的问题
说起强制转换,特别是涉及到比较操作的时候,
大家脑海中的操作往往是布尔运算
然而所谓的布尔转换,在实际转换情况并不多

除了显式的 Boolean() 以及"显式"的 !!
关于几个隐式的情况
1.三元表达式?中条件判断表达式
var b = a ? true: false;
a会被进行ToBoolean的转换
尽量还是写成  Boolean(a) 比较易读
2.if while do..while for(..;..;..;) 中的条件判断
3.逻辑运算符 ||  逻辑或 && 逻辑与 左边的操作数 请注意只有左边

### 补充说明 || 与 &&

JavaScript中的逻辑运算符和别的语言有一些重要的差别
它返回的并不是布尔值,可能你用过很多次都理所当然的认为是,其实只是返回后在条件表达式中理所当然的进行了隐式的布尔转换
它的返回值是两个操作数的一个,即选择两个操作数中的一个,所以也有人称这个运算符为选择运算符

首先对第一个操作数Toboolean后执行条件判断

- || 如果true 返回第一个,否则第二个
- && 如果false 返回第一个,否则第二个

### 宽松相等== 和严格相等 ===

> 一个常见的误区是 == 检查值是否相等, === 检查值和类型是否相等。听起来蛮有道理，但是远不够准确。
一个更常见的见解是把==和以上提到的真值假值混淆在了一起。

**“==允许在相等比较中进行强制类型转换,而===不允许”**
这里涉及到一个很重要,但是总是有人少根筋忘记的事情。
a与b类型不等的时候，到底是什么类型强制转换另一种类型进行比较？

以下规则均套路不同类型的宽松比较情况

Number> String
Number> Boolean
ToPromitive>Object

**简单说数字最大,但是数字的比较最为严格**

1.字符串和布尔值在比较中均转换toNumber继续比较
// 个人建议 在任何情况下都不要使用 == 布尔值,因为布尔值一定会被优先转换成数字
2.null 与 undefined 宽松相等,可以相互进行隐式转换
//但是和所谓的 "" false 不等,原因见1
3.对象在比较中 toprimitive操作(valueOf>toString)
4.请时刻注意自己是在进行toNumber toBoolean toprimitive操作的哪一种
令人窒息的一些非常规情况

``` javascript
"0" == false // true
"" == false // true
[] == false // true
{} == false // false
[] == ![]// true
2 == [2]// true
"" == [null] // ture 特别提醒[null] toString 返回 "" toNumber 0


```

## 补充

显式类型转换发生在静态类型语言的编译时
强制类型转换发生在动态类型语言的运行时

[github上的比较记忆图表](http://dorey.github.io/JavaScript-Equality-Table/)

ES5规范补充
> The Equals Operator ( == )

The production EqualityExpression : EqualityExpression == RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Return the result of performing abstract equality comparison rval == lval. (see 11.9.3).
11.9.2 The Does-not-equals Operator ( != )

The production EqualityExpression : EqualityExpression != RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Let r be the result of performing abstract equality comparison rval == lval. (see 11.9.3).
If r is true, return false. Otherwise, return true.
11.9.3 The Abstract Equality Comparison Algorithm

The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:

If Type(x) is the same as Type(y), then
If Type(x) is Undefined, return true.
If Type(x) is Null, return true.
If Type(x) is Number, then
If x is NaN, return false.
If y is NaN, return false.
If x is the same Number value as y, return true.
If x is +0 and y is −0, return true.
If x is −0 and y is +0, return true.
Return false.
If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return false.
If Type(x) is Boolean, return true if x and y are both true or both false. Otherwise, return false.
Return true if x and y refer to the same object. Otherwise, return false.
If x is null and y is undefined, return true.
If x is undefined and y is null, return true.
If Type(x) is Number and Type(y) is String,
return the result of the comparison x == ToNumber(y).
If Type(x) is String and Type(y) is Number,
return the result of the comparison ToNumber(x) == y.
If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.
If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).
If Type(x) is either String or Number and Type(y) is Object,
return the result of the comparison x == ToPrimitive(y).
If Type(x) is Object and Type(y) is either String or Number,
return the result of the comparison ToPrimitive(x) == y.
Return false.
NOTE 1 Given the above definition of equality:

String comparison can be forced by: "" + a == "" + b.
Numeric comparison can be forced by: +a == +b.
Boolean comparison can be forced by: !a == !b.
NOTE 2 The equality operators maintain the following invariants:

A != B is equivalent to !(A == B).
A == B is equivalent to B == A, except in the order of evaluation of A and B.
NOTE 3 The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the == operator, but the two String objects would not be equal to each other. For Example:

new String("a") == "a" and "a" == new String("a")are both true.
new String("a") == new String("a") is false.
NOTE 4 Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.

11.9.4 The Strict Equals Operator ( === )

The production EqualityExpression : EqualityExpression === RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Return the result of performing the strict equality comparison rval === lval. (See 11.9.6)
11.9.5 The Strict Does-not-equal Operator ( !== )

The production EqualityExpression : EqualityExpression !== RelationalExpression is evaluated as follows:

Let lref be the result of evaluating EqualityExpression.
Let lval be GetValue(lref).
Let rref be the result of evaluating RelationalExpression.
Let rval be GetValue(rref).
Let r be the result of performing strict equality comparison rval === lval. (See 11.9.6)
If r is true, return false. Otherwise, return true.
11.9.6 The Strict Equality Comparison Algorithm

The comparison x === y, where x and y are values, produces true or false. Such a comparison is performed as follows:

If Type(x) is different from Type(y), return false.
If Type(x) is Undefined, return true.
If Type(x) is Null, return true.
If Type(x) is Number, then
If x is NaN, return false.
If y is NaN, return false.
If x is the same Number value as y, return true.
If x is +0 and y is −0, return true.
If x is −0 and y is +0, return true.
Return false.
If Type(x) is String, then return true if x and y are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return false.
If Type(x) is Boolean, return true if x and y are both true or both false; otherwise, return false.
Return true if x and y refer to the same object. Otherwise, return false.
NOTE This algorithm differs from the SameValue Algorithm (9.12) in its treatment of signed zeroes and NaNs.