# 深入JavaScript-类型和值(1)

> a man who stands for nothing will fall for anything

## 前言

　　我一直推崇在学习深入中,加入个人的感性去理解知识。在JavaScript中Type,类型这个区域,常常惹出很多让人讨厌的BUG,常有后端过来吐槽,这也能比较，你们弱类型真是……在学习中的人尝试用各种规律去总结去记忆，去画一张炫酷的“==”比较表。JavaScript真是一门“麻烦”的语言~但是类型的出现带来的肯定不只有灾难呀~

**类型出现的目的在于确定每个变量的立场,在于让你我更清楚的认识这事物是有区别**

程序引擎和开发者在对待42（数字）不同于他们对待“42”（字符串）时，会采用不同的方式，那么这两个值的类型就应当不同。

> 我之前在大一做Java课设期间，舍友曾经问我一个问题：为什么你的程序中的学号id字段的类型是String而不是Int这样的数字类型（大意）？
学号的“数字感”，总让人第一时间就想到数字类型。后来我是这样解释的，学号不像是“数值”而更多的是一种“唯一标识”,犹如车牌号，各种楼层号。
数值的主要作用是用来计算，即加减乘除。学号顶多涉及到一个排序。

开发者对待类型不同，自然让引擎也应对待的不同。

## JavaScript中的类型

JavaScript定义了7种内置类型：

- null
- undefined
- boolean
- number
- string
- object
- symbol -- added in ES6!

### 7种类型对应着7种typeof的返回方式，然而并不是一一对应的

``` javaScript
typeof undefined     === "undefined"; // true
typeof true          === "boolean";   // true
typeof 42            === "number";    // true
typeof "42"          === "string";    // true
typeof { life: 42 }  === "object";    // true
// added in ES6!
typeof Symbol()      === "symbol";    // true
typeof null === "object"; // true
// typeof返回的第七个字符串
typeof function a(){ /* .. */ } === "function"; // true
```

### 弱类型

在JavaScript中，变量没有类型，值才有类型。
重复一次，变量没有类型，值才有类型。可以从某个很奇怪的角度说,这是弱变量,强类型。
变量可以在任何时间保存任何类型的值，这似乎很好理解，但是这到底和其他强类型语言的区别在哪里？

> “类型强制访问控制（type enforcement），表现在引擎并不要求一个变量始终保持它的初始化值的类型。
变量可以在一个赋值语句中保持string类型的值，在下一个赋值语句中又保持number的值。
值42的类型时number，它的类型不能改变。另外一个值，“42”是string 类型。
对一个变量使用typeof，并不是在问这个变量是什么类型，而是在问这个变量中储存的值是什么类型。

### undefined 和 null

首先要明白undefined是一个基本内置类型，明白这一点后，就可以更好的去明白和undeclared的区别

``` javascript
var a;
a; // undefined
b; // ReferenceError: b is not defined
```
关于这个错误以及相关的访问细节，我在[作用域](todo)部分有详细的解释

- null 指空值(empty vlaue)
- undefined 指没有值或者从未赋值(missing value)

### String

字符串不可变,这个特性和大多数语言一致。指的是字符串的成员函数操作不会改变其原始值，而是创建并返回一个新的字符串。
在JavaScript中，字符串的操作总是和数组贴合的很接近，字符串的操作，往往是拆分成“字符数组”的操作。
其实String也是类数组对象
用原始的思路，就像是把他拆包又打包回来。但是有很多数组函数其实是可以被字符串直接操作处理的。

``` javascript
var a = 'cosine'
var b = a.split('').reverse().join('') //流畅的思路,字符串反转
// 创建副本,借用数组的成员函数来进行join的操作
var c = Array.prototype.join.call(a,"-")
// 为什么我们不试试借用reverse呢
var d = Array.prototype.reverse.call(a);//TypeError: Cannot assign to read only property '0' of object '[object String]' at String.reverse (native)
```

想一下,join 和 reverse 有什么本质上的区别。
数组方法中，有很多不一样的方法，一些方法会操作修改到原有数组，一些则是作为拷贝返回新的数组。
刚才提到的字符串不变性的问题,这里显然报出read only的错误了。

关于内置对象中的一些其他方法，我就不在说了，可以分出专题写常用的一些操作方法

## Number

这一直是JavaScript令人诟病的类型，因为只有一种数值类型，而且是常常惹事的 双精度浮点数
二进制浮点数最大的问题

``` javascript
0.1 + 0.2 === 0.3; // false

```

!! 注意这个问题,之前又有一个后端过来吐槽，返回的明明是long，但是最后的数字全部变成了0
[为什么不要在JavaScript中使用位操作符](http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/)
>虽然说整数最大能到达到53位，但是有些数字操作(如数位操作)值适用于32位数字，所以这些操作中数字的安全范围就要小很多。a|0 可以将变量a中的数值转换位32位有符号整数，因为数位运算符 | 只适用于32位有符号整数

## Array

这里更关注值的类型特性，数组其实不属于这里的范畴，数组更多关注一些内置的方法操作和类对象特性显露。请关注深入系列数组。