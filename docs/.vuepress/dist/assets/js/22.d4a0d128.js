(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{348:function(a,t,n){"use strict";n.r(t);var s=n(0),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("p",[a._v("3月博客归档计划中……")]),a._v(" "),n("h2",{attrs:{id:"_1-1-编译原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-编译原理"}},[a._v("#")]),a._v(" 1.1 编译原理")]),a._v(" "),n("p",[a._v("JavaScript事实上是一门动态编译语言\n所有执行的语句都需要编译，只是过程十分短暂。而且并不是提前编译的，也不能在分布式系统中进行移植，更像是一边执行一边编译。也是正因为如此（JavaScript引擎不会有大量的时间进行编译，也没有那么多时间进行优化。因为不是发生在构建之前），这种“编译”过程会掺杂很多优化。")]),a._v(" "),n("p",[a._v("传统的编译过程分为三个步骤：")]),a._v(" "),n("ul",[n("li",[a._v("1.词法分析\n对语句进行分词，按照一定的字符串组成规则。")]),a._v(" "),n("li",[a._v("2.解析、语法分析\n将词法单元流转换成抽象语法树。")]),a._v(" "),n("li",[a._v("3.代码生成\n将抽象语法树转换为可执行的代码")])]),a._v(" "),n("p",[a._v("JavaScript也是有类似的过程，但是会更加复杂。")]),a._v(" "),n("h3",{attrs:{id:"_1-2理解作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2理解作用域"}},[a._v("#")]),a._v(" 1.2理解作用域")]),a._v(" "),n("h4",{attrs:{id:"关于javascript解析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于javascript解析"}},[a._v("#")]),a._v(" 关于javascript解析")]),a._v(" "),n("p",[a._v("3大角色")]),a._v(" "),n("ul",[n("li",[a._v("1.编译器")]),a._v(" "),n("li",[a._v("2.引擎")]),a._v(" "),n("li",[a._v("3.作用域\n这里将javascript定义为编译性质的语言，以一种极快的速度进行编译，然后运行。不像其他语言一样，采用编译后再运行。更类似于一边编译，一边运行。当然这也是传统定义中，解释型语言的样子了。")])]),a._v(" "),n("h3",{attrs:{id:"‘var-a-2-’一条简单语句的执行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#‘var-a-2-’一条简单语句的执行过程"}},[a._v("#")]),a._v(" ‘var a = 2;’一条简单语句的执行过程")]),a._v(" "),n("p",[a._v("1.将语句进行词法分解，分解成词法单元，然后解析成为词法树。在这个过程中出错，则报出语法错误。\n2.词法树编译，遇到var a\n编译器会询问（搜索）作用域是否存在该名称的变量，如果存在，则忽略该声明，继续进行编译（词法树的继续展开）。否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a\n3.遇到a = 2 , 词法树的编译会为引擎生成运行时所需要的代码，这个代码需要处理这一个a = 2 的赋值操作。\n4.引擎运行这段代码，首先会搜索当前作用域是否有a这个变量，如果是，引擎就会使用这个变量（注意一下，这里还真不一定说一定会有，详细见之前说的变量提升hosting问题），否则引擎会继续查找该变量。\n如果找到了该变量，则继续赋值\n如果找不到，则举手抛出一个异常")]),a._v(" "),n("h3",{attrs:{id:"关于以上说的编译器-引擎执行的对变量a的查找"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于以上说的编译器-引擎执行的对变量a的查找"}},[a._v("#")]),a._v(" 关于以上说的编译器/引擎执行的对变量a的查找")]),a._v(" "),n("p",[a._v("在上述的例子中，引擎会为变量a使用LHS的查找\n查找一共有两种方式\n一种是LHS，另一种则是RHS\n当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询")]),a._v(" "),n("p",[a._v("大概可以这样理解\nLHS是找到变量的地址\nRHS则是找到变量的地址中存放的值。\nRHS(retrieve his source value)取得他的源值\n"),n("strong",[a._v("只要是涉及到赋值操作，就一定会有LHS的左侧搜索，它也有可能是在隐式中发生")])]),a._v(" "),n("div",{staticClass:"language-javascript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-javascript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("a")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),n("p",[a._v("上述代码中，除了foo()发生了RHS的foo值搜索以外，\n还发生了a = 2 的隐式LHS的引用搜索，以及console对象的RHS对象值搜索")]),a._v(" "),n("p",[a._v("当然，在预编译过程中的function 函数声明，我现有的知识知道这和正常的var声明不一样。\n事实上，函数声明是另外的一种方式进行编译的。\n狗日的真复杂")]),a._v(" "),n("h3",{attrs:{id:"_1-4异常"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4异常"}},[a._v("#")]),a._v(" 1.4异常")]),a._v(" "),n("p",[a._v("区分 referenceError异常和TypeError")]),a._v(" "),n("h2",{attrs:{id:"函数作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[a._v("#")]),a._v(" 函数作用域")]),a._v(" "),n("blockquote",[n("p",[a._v("从所写的代码中挑选出一个片段，然后用函数声明对它进行包装，实际上就是把这些代码‘隐藏’了")])]),a._v(" "),n("h1",{attrs:{id:"hosting"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hosting"}},[a._v("#")]),a._v(" hosting")]),a._v(" "),n("p",[a._v("我们来看看 var 声明的「创建、初始化和赋值」过程")]),a._v(" "),n("p",[a._v("假设有如下代码：")]),a._v(" "),n("p",[a._v("function fn(){\nvar x = 1\nvar y = 2\n}\nfn()\n在执行 fn 时，会有以下过程（不完全）：")]),a._v(" "),n("p",[a._v("进入 fn，为 fn 创建一个环境。\n找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。\n将这些变量「初始化」为 undefined。\n开始执行代码\nx = 1 将 x 变量「赋值」为 1\ny = 2 将 y 变量「赋值」为 2\n也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。")]),a._v(" "),n("p",[a._v("这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。")]),a._v(" "),n("blockquote"),a._v(" "),n("p",[a._v("看到这里，你应该明白了 let 到底有没有提升：")]),a._v(" "),n("p",[a._v("let 的「创建」过程被提升了，但是初始化没有提升。\nvar 的「创建」和「初始化」都被提升了。\nfunction 的「创建」「初始化」和「赋值」都被提升了。")]),a._v(" "),n("p",[a._v("最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。")])])}),[],!1,null,null,null);t.default=r.exports}}]);