(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{349:function(t,a,r){"use strict";r.r(a);var s=r(0),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"高性能的javascript-笔记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#高性能的javascript-笔记"}},[t._v("#")]),t._v(" 高性能的JavaScript 笔记")]),t._v(" "),r("h3",{attrs:{id:"script-标签篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#script-标签篇"}},[t._v("#")]),t._v(" script 标签篇")]),t._v(" "),r("p",[t._v("1.script脚本放在body尾部\n把script脚本放在页面的顶端，将导致一个可以察觉的延迟\n白屏，执行script标签的下载和运行，而且必须等到第一个文件下载并运行后，才会开始第二个文件的下载。（这个是几个浏览器版本更新后的优化点，虽然后面优化了，但是JavaScript的下载仍然要阻塞其他资源的下载过程，例如图片）\n2.合并脚本\n下载一个100KB的脚本比下载四个25KB的脚本要快\n3.defer属性会延时执行，会在DOM完成之后才有可能被执行\n4.动态脚本在这个额元素添加到页面后立即开始下载：文件的下载和运行都不会阻塞其他页面的处理过程\n小贤注：这个是JSONP的一个方案，返回的脚本一般是立即执行函数，而且可以通过readystate属性来获取状态（待具体TODO）\n5.使用XHR创建动态脚本。（TODO 4.5和JSONP）")]),t._v(" "),r("h3",{attrs:{id:"变量篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#变量篇"}},[t._v("#")]),t._v(" 变量篇")]),t._v(" "),r("p",[t._v("抛出问题：\nJavaScript中有几种访问数据方式：\n1.通过变量\n2.对象成员\n3.数组项（广义上说2,3可以合并）\n4.直接值\n这里只是说了，访问对象成员会比直接通过变量访问会慢很多。\n注：这是自然，对象成员进行原型链搜索，我把这种叫做：成员搜索。通过变量的访问叫做右值引用。")]),t._v(" "),r("h3",{attrs:{id:"作用域篇"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用域篇"}},[t._v("#")]),t._v(" 作用域篇")]),t._v(" "),r("p",[t._v("不想说，累了。\n扯半天只是说越深越慢。废话，搜索要性能当然。\n3")]),t._v(" "),r("h2",{attrs:{id:"p42"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#p42"}},[t._v("#")]),t._v(" P42")])])}),[],!1,null,null,null);a.default=n.exports}}]);