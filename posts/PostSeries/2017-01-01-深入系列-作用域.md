作用域是什么？
<!-- more -->

## 1.1 编译原理
JavaScript事实上是一门动态编译语言
所有执行的语句都需要编译，只是过程十分短暂。而且并不是提前编译的，也不能在分布式系统中进行移植，更像是一边执行一边编译。也是正因为如此（JavaScript引擎不会有大量的时间进行编译，也没有那么多时间进行优化。因为不是发生在构建之前），这种“编译”过程会掺杂很多优化。

传统的编译过程分为三个步骤：
- 1.词法分析
对语句进行分词，按照一定的字符串组成规则。
- 2.解析、语法分析
将词法单元流转换成抽象语法树。
- 3.代码生成
将抽象语法树转换为可执行的代码

JavaScript也是有类似的过程，但是会更加复杂。

### 1.2理解作用域
#### 关于javascript解析
3大角色
- 1.编译器
- 2.引擎
- 3.作用域
这里将javascript定义为编译性质的语言，以一种极快的速度进行编译，然后运行。不像其他语言一样，采用编译后再运行。更类似于一边编译，一边运行。当然这也是传统定义中，解释型语言的样子了。

### ‘var a = 2;’一条简单语句的执行过程
1.将语句进行词法分解，分解成词法单元，然后解析成为词法树。在这个过程中出错，则报出语法错误。
2.词法树编译，遇到var a
编译器会询问（搜索）作用域是否存在该名称的变量，如果存在，则忽略该声明，继续进行编译（词法树的继续展开）。否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a
3.遇到a = 2 , 词法树的编译会为引擎生成运行时所需要的代码，这个代码需要处理这一个a = 2 的赋值操作。
4.引擎运行这段代码，首先会搜索当前作用域是否有a这个变量，如果是，引擎就会使用这个变量（注意一下，这里还真不一定说一定会有，详细见之前说的变量提升hosting问题），否则引擎会继续查找该变量。
如果找到了该变量，则继续赋值
如果找不到，则举手抛出一个异常

### 关于以上说的编译器/引擎执行的对变量a的查找
在上述的例子中，引擎会为变量a使用LHS的查找
查找一共有两种方式
一种是LHS，另一种则是RHS
当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询

大概可以这样理解
LHS是找到变量的地址
RHS则是找到变量的地址中存放的值。
RHS(retrieve his source value)取得他的源值
**只要是涉及到赋值操作，就一定会有LHS的左侧搜索，它也有可能是在隐式中发生**
``` javascript
function foo(a){
    console.log(a);
}
foo(2)
```
上述代码中，除了foo()发生了RHS的foo值搜索以外，
还发生了a = 2 的隐式LHS的引用搜索，以及console对象的RHS对象值搜索

当然，在预编译过程中的function 函数声明，我现有的知识知道这和正常的var声明不一样。
事实上，函数声明是另外的一种方式进行编译的。
狗日的真复杂

### 1.4异常

区分 referenceError异常和TypeError



## 函数作用域
> 从所写的代码中挑选出一个片段，然后用函数声明对它进行包装，实际上就是把这些代码‘隐藏’了


# hosting

我们来看看 var 声明的「创建、初始化和赋值」过程

假设有如下代码：

function fn(){
  var x = 1
  var y = 2
}
fn()
在执行 fn 时，会有以下过程（不完全）：

进入 fn，为 fn 创建一个环境。
找到 fn 中所有用 var 声明的变量，在这个环境中「创建」这些变量（即 x 和 y）。
将这些变量「初始化」为 undefined。
开始执行代码
x = 1 将 x 变量「赋值」为 1
y = 2 将 y 变量「赋值」为 2
也就是说 var 声明会在代码执行之前就将「创建变量，并将其初始化为 undefined」。

这就解释了为什么在 var x = 1 之前 console.log(x) 会得到 undefined。

>
看到这里，你应该明白了 let 到底有没有提升：

let 的「创建」过程被提升了，但是初始化没有提升。
var 的「创建」和「初始化」都被提升了。
function 的「创建」「初始化」和「赋值」都被提升了。


最后看 const，其实 const 和 let 只有一个区别，那就是 const 只有「创建」和「初始化」，没有「赋值」过程。