---
title: 深入JavaScript-类型和值-类型和值基础
date: 2017-01-01 00::00:00
categories:
- JavaScript
tags:
- JavaScript
- 深入系列
---

# 深入JavaScript-类型和值-第一部分
## 前言
> 只要是程序员都会的语言，JavaScript却总是惹人生厌，弱类型语言，天生长着一副满图坑的脸，他就像是恶魔，你越是逃避，越是侵蚀，只有真正了解他的特性才能很好的驯服。
** 2018 复习归档修正 **
**类型在于明确每个值的立场,让程序员清楚认识事物之间的区别**
**开发者对待类型不同，自然让引擎也应对待的不同**
<!-- more -->


> 程序引擎和开发者在对待42（数字）不同于他们对待“42”（字符串）时，会采用不同的方式，那么这两个值的类型就应当不同。
为什么课程设计程序中的学号id字段的类型是String而不是Int这样的数字类型？
学号的“数字感”，总让人第一时间就想到数字类型。后来我是这样解释的，学号不像是“数值”而更多的是一种“唯一标识”,犹如车牌号，各种楼层号。数值的主要作用是用来计算，即加减乘除。而学号顶多涉及到一个排序。（这只是一种理解方式）

## JavaScript中7种内置类型

- null
- undefined
- boolean
- number
- string
- object
- symbol

### 7种类型对应着7种typeof的返回方式

**注意并不是值和typeof运算值并不是完全相对应的**
- typeof null 属于历史遗留BUG，永远也不会修复。
- function虽然不是类型，但是也能被typeof识别。

``` javaScript
typeof undefined     === "undefined"; // true
typeof true          === "boolean";   // true
typeof 42            === "number";    // true
typeof "42"          === "string";    // true
typeof { life: 42 }  === "object";    // true
// added in ES6!
typeof Symbol()      === "symbol";    // true
typeof null === "object"; // true 
// typeof返回的第七个字符串
typeof function a(){ /* .. */ } === "function"; // true
```

## 弱类型是什么？

在JavaScript中，变量没有类型，值才有类型。
**重复一次，变量没有类型，值才有类型。**
　　可以从某个很奇怪的角度说,这是弱变量,强类型。变量可以在任何时间保存任何类型的值，这似乎很好理解，但是这到底和其他强类型语言的区别在哪里？
> “类型强制访问控制（type enforcement），表现在引擎并不要求一个变量始终保持它的初始化值的类型。变量可以在一个赋值语句中保持string类型的值，在下一个赋值语句中又保持number的值。值42的类型时number，它的类型不能改变。另外一个值，“42”是string 类型。
对一个变量使用typeof，并不是在问这个变量是什么类型，而是在问这个变量中储存的值是什么类型。
--
后补充：这里在我后面文章值和引用中，提出了《你不知道的JavaScript》的的概念：
使用变量的时候本身是属于RHS 右值查询
而变量本身的声明和存在，则是 LHS 左变量搜索

## 不谈转换，类型基础理解

### undefined 和 null

首先要明白undefined是一个基本内置类型，明白这一点后，就可以更好的去明白和undeclared的区别

``` javascript
var a;
a; // undefined
b; // ReferenceError: b is not defined
```

- null 指空值(empty vlaue)
- undefined 指没有值或者从未赋值(missing value)

### String

**字符串这边没有太多可以说的，下面说的不可变，也只是值传递的表现现象而已**

字符串不可变。(事实上在JavaScript中所有标量基本类型值都是不可更改的,Number,Boolean,String)
指的是字符串的成员函数操作不会改变其原始值，而是创建并返回一个新的字符串。
在JavaScript中，字符串的操作总是和数组贴合的很接近，字符串的操作，往往是拆分成“字符数组”的操作。

``` javascript
// 字符串颠倒
var a = 'cosine'
var b = a.split('').reverse().join('') //字符串反转
// 创建副本,借用数组的成员函数来进行join的操作
var c = Array.prototype.join.call(a,"-")
// 为什么我们不试试借用reverse呢
var d = Array.prototype.reverse.call(a);//TypeError: Cannot assign to read only property '0' of object '[object String]' at String.reverse (native)
```

想一下,join 和 reverse 有什么本质上的区别。
数组方法中，有很多不一样的方法，一些方法会操作修改到原有数组，一些则是作为拷贝返回新的数组。
刚才提到的字符串不变性的问题,这里显然报出read only的错误了。

关于内置对象中的一些其他方法，我就不在说了，可以分出专题写常用的一些操作方法

## Number

这一直是JavaScript令人诟病的类型，因为只有一种数值类型，而且是常常惹事的双精度浮点数
二进制浮点数最大的问题

### 浮点精度

``` javascript
0.1 + 0.2 === 0.3; // false

```
**Number最大的坑就是安全范围2E53-1，只有53位，精度问题都有**
处理上面这个精度问题，简单的话可以使用 Number.EPSILON 这个机器精度常量值来解决。

### 浮点数字语法的细节

``` javascript
42.toFixed(3) // 语法错误
(42).toFixed(3)
42..toFixed(3)
```
当然不推荐上面这种使用原生函数的方式，但是要注意一个坑
“42.”会被编译器认为是“42.0”省略0的写法。

### 关于位运算符

[为什么不要在JavaScript中使用位操作符](http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/)
>虽然说整数最大能到达到53位，但是有些数字操作(如数位操作)值适用于32位数字，所以这些操作中数字的安全范围就要小很多。a|0 可以将变量a中的数值转换位32位有符号整数，因为数位运算符 | 只适用于32位有符号整数

### 关于NAN
- 请使用Number.isNaN 函数来判断
- NaN是JavaScript中唯一一个不等于自身的值
``` javascript
if(!Number.isNaN){
  Number.isNaN = function(n) {
      return n !== n;
  }
}

```
## Boolean

布尔类型除了开关的Flag的天性设计，最大的感受是为了判断符而生的。

注意不要使用 new Boolean这个原生函数，这其实也违背了我上一句说的话。
这根本一点 也不判断。
``` javascript
var bool = new Boolean(false);
if (bool) {
	alert('true');
} else {
	alert('false');
}
// true
```
这个没什么意义的面试题和类型转换有关。


## Array

严格来说数组不属于类型，这里更关注值的类型特性。
数组更多关注一些内置的方法操作和类对象特性显露。
后面有文章会说~