---
title: 深入JavaScript-类型和值-类型和值基础
date: 2017-01-01 00:00:00
categories:
- JavaScript
tags:
- JavaScript
- 深入系列
---

# 深入JavaScript-类型和值-第一部分
## 前言
> 只要是程序员都会的语言，JavaScript却总是惹人生厌，弱类型语言，天生长着一副满图坑的脸，他就像是恶魔，你越是逃避，越是侵蚀，只有真正了解他的特性才能很好的驯服。
** 2018 复习归档修正 **
**类型在于明确每个值的立场,让程序员清楚认识事物之间的区别**
**开发者对待类型不同，自然让引擎也应对待的不同**
<!-- more -->


> 程序引擎和开发者在对待42（数字）不同于他们对待“42”（字符串）时，会采用不同的方式，那么这两个值的类型就应当不同。
为什么课程设计程序中的学号id字段的类型是String而不是Int这样的数字类型？
学号的“数字感”，总让人第一时间就想到数字类型。后来我是这样解释的，学号不像是“数值”而更多的是一种“唯一标识”,犹如车牌号，各种楼层号。数值的主要作用是用来计算，即加减乘除。而学号顶多涉及到一个排序。（这只是一种理解方式）

## JavaScript中7种内置类型

- null
- undefined
- boolean
- number
- string
- object
- symbol

### 7种类型对应着7种typeof的返回方式

**注意并不是值和typeof运算值并不是完全相对应的**
- typeof null 属于历史遗留BUG，永远也不会修复。
- function虽然不是类型，但是也能被typeof识别。

``` javaScript
typeof undefined     === "undefined"; // true
typeof true          === "boolean";   // true
typeof 42            === "number";    // true
typeof "42"          === "string";    // true
typeof { life: 42 }  === "object";    // true
// added in ES6!
typeof Symbol()      === "symbol";    // true
typeof null === "object"; // true 
// typeof返回的第七个字符串
typeof function a(){ /* .. */ } === "function"; // true
```
### 内建函数(原生函数)

所有typeof 返回值为"object"的对象(如数组)都包含一个内部属性[[Class]]
这个属性无法直接访问
通过Object.prototype.toString来查看

``` javascript
Object.prototype.toString.call( [1,2,3]) // "[object Array]"
// 值得注意的是,基本类型值也会自动包装获得相同的情况
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(42) // "[object Number]"
Object.prototype.toString.call("abc") // "[object String]"

```

## 弱类型是什么？

在JavaScript中，变量没有类型，值才有类型。
**重复一次，变量没有类型，值才有类型。**
　　可以从某个很奇怪的角度说,这是弱变量,强类型。变量可以在任何时间保存任何类型的值，这似乎很好理解，但是这到底和其他强类型语言的区别在哪里？
> “类型强制访问控制（type enforcement），表现在引擎并不要求一个变量始终保持它的初始化值的类型。变量可以在一个赋值语句中保持string类型的值，在下一个赋值语句中又保持number的值。值42的类型时number，它的类型不能改变。另外一个值，“42”是string 类型。
对一个变量使用typeof，并不是在问这个变量是什么类型，而是在问这个变量中储存的值是什么类型。
--
后补充：这里在我后面文章值和引用中，提出了《你不知道的JavaScript》的的概念：
使用变量的时候本身是属于RHS 右值查询
而变量本身的声明和存在，则是 LHS 左变量搜索

## 不谈转换，类型基础理解

### undefined 和 null

首先要明白undefined是一个基本内置类型，明白这一点后，就可以更好的去明白和undeclared的区别

``` javascript
var a;
a; // undefined
b; // ReferenceError: b is not defined
```

- null 指空值(empty vlaue)
- undefined 指没有值或者从未赋值(missing value)

### typeof undefined
``` javascript
var a;
typeof a; // "undefined"
typeof b; // "undefined"
```

> typeof运算符返回"undefined"，尽管这个变量是“undeclared”（或“not defined”，未定义的变量）。请注意，当我们执行typeof b的时候没有抛出任何错误，尽管b是一个未声明的变量。这是typeof的特殊安全保护机制造成的。
如果typeof针对未声明的变量返回“undeclared”，而不是将两种完全不同情况混为一谈都返回“undefined”，这该多好啊！Nevertheless, this safety guard is a useful feature when dealing with JavaScript in the browser, where multiple script files can load variables into the shared global namespace.

``` javascript
// 可以用来防止抛出ReferenceError
// oops, this would throw an error!
if (DEBUG) {
    console.log( "Debugging is starting" );
}
// this is a safe existence check
if (typeof DEBUG !== "undefined") {
    console.log( "Debugging is starting" );
}
```

### String

**字符串这边没有太多可以说的，下面说的不可变，也只是值传递的表现现象而已**

字符串不可变。(事实上在JavaScript中所有标量基本类型值都是不可更改的,Number,Boolean,String)
指的是字符串的成员函数操作不会改变其原始值，而是创建并返回一个新的字符串。
在JavaScript中，字符串的操作总是和数组贴合的很接近，字符串的操作，往往是拆分成“字符数组”的操作。

``` javascript
// 字符串颠倒
var a = 'cosine'
var b = a.split('').reverse().join('') //字符串反转
// 创建副本,借用数组的成员函数来进行join的操作
var c = Array.prototype.join.call(a,"-")
// 为什么我们不试试借用reverse呢
var d = Array.prototype.reverse.call(a);//TypeError: Cannot assign to read only property '0' of object '[object String]' at String.reverse (native)
```

想一下,join 和 reverse 有什么本质上的区别。
数组方法中，有很多不一样的方法，一些方法会操作修改到原有数组，一些则是作为拷贝返回新的数组。
刚才提到的字符串不变性的问题,这里显然报出read only的错误了。

**关于内置对象中的一些其他方法，我这里就不总结了，可以分出专题写常用的一些操作方法**
### 字符串和字符串对象

> 基本字符串和字符串对象的区别
请注意区分 JavaScript 字符串对象和基本字符串值 . ( 对于 Boolean 和Numbers 也同样如此.)

字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。JavaScript会自动将基本字符串转换为字符串对象，只有将基本字符串可转化为字符串对象之后才可以使用字符串对象的方法。当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。
## Number

这一直是JavaScript令人诟病的类型，因为只有一种数值类型，而且是常常惹事的双精度浮点数
二进制浮点数最大的问题

### 浮点精度

``` javascript
0.1 + 0.2 === 0.3; // false

```
**Number最大的坑就是安全范围2E53-1，只有53位，精度问题都有**
处理上面这个精度问题，简单的话可以使用 Number.EPSILON 这个机器精度常量值来解决。

### 浮点数字语法的细节

``` javascript
42.toFixed(3) // 语法错误
(42).toFixed(3)
42..toFixed(3)
```
当然不推荐上面这种使用原生函数的方式，但是要注意一个坑
“42.”会被编译器认为是“42.0”省略0的写法。

### 关于位运算符

[为什么不要在JavaScript中使用位操作符](http://jerryzou.com/posts/do-you-really-want-use-bit-operators-in-JavaScript/)
>虽然说整数最大能到达到53位，但是有些数字操作(如数位操作)值适用于32位数字，所以这些操作中数字的安全范围就要小很多。a|0 可以将变量a中的数值转换位32位有符号整数，因为数位运算符 | 只适用于32位有符号整数

### 关于NAN
- 请使用Number.isNaN 函数来判断
- NaN是JavaScript中唯一一个不等于自身的值
``` javascript
if(!Number.isNaN){
  Number.isNaN = function(n) {
      return n !== n;
  }
NaN != NaN;// true
NaN !== NaN;// true
NaN == NaN;
NaN === NaN;

```

### 判断方法

- 利用唯一一个非自反值来判断
- 利用全局函数window.isNaN来判断


## Boolean

布尔类型除了开关的Flag的天性设计，最大的感受是为了判断符而生的。

注意不要使用 new Boolean这个原生函数，这其实也违背了我上一句说的话。
这根本一点 也不判断。
``` javascript
var bool = new Boolean(false);
if (bool) {
	alert('true');
} else {
	alert('false');
}
// true
```
这个没什么意义的面试题和类型转换有关。


## Array

严格来说数组不属于类型，这里更关注值的类型特性。
数组更多关注一些内置的方法操作和类对象特性显露。
后面有文章会说~

