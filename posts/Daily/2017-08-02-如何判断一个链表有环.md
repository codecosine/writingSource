# 如何判断一个链表有环

> 这是面试遇到的一道题目。怪自己准备不充分吧,这个属于算法很基础的题目,有点懵逼之余也不知道说些什么好了。其实当时有点意外问了算法,挂了电话后我倒是很轻松想到一些解决的思路方向。

## 1
这里先说自己开始的想法，相信也应该是最容易想到的。

首先先明确。什么叫链表有环。

1.正常的链表，一条到底
2.首尾相接的链表，就是一个整环，满足题意
3.一条链表中间有一个环，其实是只可能在尾部有环，满足题意

很容易就发现,3的情况是1和2的相同,那只要将3的情况化为2的情况解决就可以了。
最容易想到的解决方式是,把每一个3中的节点都按2处理一次

### 2情况解决的方式

找到尾部,判断尾部的下一条是不是头节点
不知道哪里是尾部,所以从头开始,中途的下一节点有和头地址相等就是环

``` javascript
Node head = new Node() // node 内部的 valueOf 方法会重写
function isLoop(head){
    var current = head;
    while(current){
        if(current.next == head){
            console.log('isloop')
            return true;
        } else{            
            current = cuurent.next;
        }
    }
    return false;
}

// 由于这个方法在遇到3的情况的时候,会产生死循环,我想了很久发现好像只能将所有路过的指针都存在一个区域里,然后next再和每一个进行比较,似乎是可行,但是显然增加了一些不需要的复杂度

```

### 好了不扯,我在网上找了一些方案

> 假设有两个学生A和B在跑道上跑步，两人从相同起点出发，假设A的速度为2m/s，B的速度为1m/s,结果会发生什么？答案很简单，A绕了跑道一圈之后会追上B！

我想了一下有一个问题,直道的时候会超出一段距离,导致在环道上起点不一致。又想了一下，发现这就是这个方案要解决的问题。我跑的比你快,只要有环我总会套圈你,在套圈的一瞬间我们一定重合,重合一定说明我们有环,也同时重置一次起点。(起点在哪无所谓)

后来我想，这个方案其实是我开始想的“失败”方案的思路的跳板。真糟糕！产生了死循环。但是好像尾环肯定就会死循环，要是有什么方法能判断产生了这种死循环就好了。

只要我们在跑圈,无论开始如何,只要我跑的比你快,我一定会追上你一次。


``` javascript
Node head = new Node() // node 内部的 valueOf 方法会重写
function isLoop(head){
    var fast = head.next; //为了防止第一次比较的时候就相等
    var slow = head;
    while(fast){
        if(fast == slow){
            console.log('isloop')
            return true;
        } else{            
            slow = slow.next;
            fast = fast.next;
            if(!fast){
                return false;
            } else {
               fast = fast.next;
            }
        }
    }
    return false;
}


```

### 关于算法知识的一些随口吐槽
答不出来的时候我也暴躁的说算法有什么用，还不是多见过一些题目，记下来了而已，比记忆力没什么意思。继而我也想到以前的一些事情，其实是不一样的。第一说明你有用心做了这个“记忆"的工作，第二，没有这些熟悉的”记忆”，在很多真正需要“脑子”的地方，你就反应不出来，高中的时候学数学解一些难题就往往有这些感慨，其实根本不是“灵感”，只是踩在了一些“记忆”中的想法